[{"categories":["设计模式"],"content":"单例模式只允许创建一个对象，因此节省内存，加快对象访问速度，因此对象需要被公用的场合适合使用，如多个模块使用同一个数据源连接对象等等。如： 需要频繁实例化然后销毁的对象。 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 有状态的工具类对象。 频繁访问数据库或文件的对象。 以下都是单例模式的经典使用场景： 资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。 控制资源的情况下，方便资源之间的互相通信。如线程池等。 ","date":"2022-09-14","objectID":"/posts/singleton_pattern/:0:0","series":null,"tags":["设计模式"],"title":"单例模式","uri":"/posts/singleton_pattern/#"},{"categories":["设计模式"],"content":"从饿汉式写法到懒汉式写法饿汉式就是用类变量存储初始化的实例。 public class Singleton { private static volatile Singleton singleton; private Singleton() { } public static Singleton getSingletonInstance(){ return singleton; } } 注意\r\r饿汉式的缺点是假设不需要用到这个类的实例，但是它仍然初始化了。实际应用中这并不是一个大问题。\r\r 懒汉式的写法最完美的是双重判断加锁，同时使用volatile保证可见性。 public class Singleton { private static volatile Singleton singleton; private Singleton() { } public static Singleton getSingletonInstance(){ if (singleton == null) { //可能两个线程同时判断通过 synchronized (Singleton.class) { try { Thread.sleep(1); } catch (InterruptedException e) { throw new RuntimeException(e); } if (singleton == null) { singleton = new Singleton(); } } } return singleton; } public static void main(String[] args) { for (int i = 0; i \u003c 1000; i ++) { new Thread(() -\u003e { System.out.println(Singleton.getInstance().hashCode()); }).start(); } } } ","date":"2022-09-14","objectID":"/posts/singleton_pattern/:1:0","series":null,"tags":["设计模式"],"title":"单例模式","uri":"/posts/singleton_pattern/#从饿汉式写法到懒汉式写法"},{"categories":["设计模式"],"content":"内部类在类中创建一个内部类，比懒汉式优雅，需要更高的jdk版本支持。 public class Singleton { private Singleton() { } private class SingletonInstance{ private final static Singleton INSTANCE= new Singleton(); } public static Singleton getInstance() { return SingletonInstance.INSTANCE; } public static void main(String[] args) { for (int i = 0; i \u003c 1000; i ++) { new Thread(() -\u003e { System.out.println(Singleton.getInstance().hashCode()); }).start(); } } } ","date":"2022-09-14","objectID":"/posts/singleton_pattern/:2:0","series":null,"tags":["设计模式"],"title":"单例模式","uri":"/posts/singleton_pattern/#内部类"},{"categories":["设计模式"],"content":"枚举最简单的当然还是枚举类了，在枚举类中，每个实例的类型就是该枚举类。如下面代码，INSTANCE的类型为SingletonEnum。 并且枚举类在jvm层面线程安全，还可以防止序列化和反射攻击，应该说是一种最佳实践,写法相当优雅。 public enum SingletonEnum{ INSTANCE; //测试代码 public static void main(String[] args) { for (int i = 0; i \u003c 1000; i ++) { new Thread(() -\u003e { System.out.println(SingletonEnum.INSTANCE.hashCode()); }).start(); } } } ","date":"2022-09-14","objectID":"/posts/singleton_pattern/:3:0","series":null,"tags":["设计模式"],"title":"单例模式","uri":"/posts/singleton_pattern/#枚举"},{"categories":["并发"],"content":"synchronizedsynchronized是java虚拟机层面实现的锁, 一般的使用： synchronized (lock) { // while() { lock.wait(); } // lock.notify();//lock.notifyAll(); } 在写一个程序时报错，java.lang.IllegalMonitorStateException。分析代码后发现时因为把Boolean类用作了锁。 原因是类似Integer Boolean等基本类型的包装类的值是不可变的,而假设对一个Integer进行++类似的操作，实际上所引用的对象已经发生了改变。 private final int value; 在写https://leetcode.cn/problems/fizz-buzz-multithreaded/submissions/ 这道题时出现了一个诡异的错误，明明正确打印了所有的字符串，但是却始终报超时 我的代码如下： class FizzBuzz { private int n; public FizzBuzz(int n) { this.n = n; } private volatile int i = 1; public void fizz(Runnable printFizz) throws InterruptedException { while (i \u003c= n) synchronized (this) { while (!(i % 3 == 0 \u0026\u0026 i % 5 != 0)) { this.wait(); } if (i \u003c= n \u0026\u0026 i % 3 == 0 \u0026\u0026 i % 5 != 0) { printFizz.run(); i ++; } this.notifyAll(); } } // printBuzz.run() outputs \"buzz\". public void buzz(Runnable printBuzz) throws InterruptedException { while (i \u003c= n) synchronized (this) { while (!(i % 5 == 0 \u0026\u0026 i % 3 != 0)) { this.wait(); } if (i \u003c= n \u0026\u0026 i % 5 == 0 \u0026\u0026 i % 3 != 0) { printBuzz.run(); i ++; } this.notifyAll(); } } // printFizzBuzz.run() outputs \"fizzbuzz\". public void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException { while (i \u003c= n) synchronized (this) { while (!(i % 5 == 0 \u0026\u0026 i % 3 == 0)) { this.wait(); } if (i \u003c= n \u0026\u0026 i % 5 == 0 \u0026\u0026 i % 3 == 0) { printFizzBuzz.run(); i ++; } this.notifyAll(); } } // printNumber.accept(x) outputs \"x\", where x is an integer. public void number(IntConsumer printNumber) throws InterruptedException { while (i \u003c= n) synchronized (this) { while (i % 5 == 0 || i % 3 == 0) { this.wait(); } if (i \u003c= n \u0026\u0026 !(i % 5 == 0 || i % 3 == 0)) { printNumber.accept(i); i ++; } this.notifyAll(); } } } 那么虽然正确地同步了线程，但是却无法正常退出，分析可知，唯一可能的原因在于这段代码： while (i % 5 == 0 || i % 3 == 0) { this.wait(); } 对于四个线程都是一样，当其他线程满足退出了，之前正在等待的线程由于i无法再更新，会一直卡在这个地方，无法正常退出，修改的方式也很简单，只需要在判断添加中加上i \u003c= n；这样当程序结束不会再循环等待。 ","date":"2022-08-14","objectID":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B/concurrency/:1:0","series":null,"tags":["并发","多线程"],"title":"java中的锁","uri":"/posts/%E5%A4%9A%E7%BA%BF%E7%A8%8B/concurrency/#synchronized"},{"categories":["数据库"],"content":"SQL的连接SQL的连接可以分为内连接（默认，不需要写 inner join）、左连接(left join/ left outer join)、右连接(right join/ right outer join)、全连接（full join, Mysql不直接支持，可以使用union实现） 左连接就是保留左边表没有与右边表匹配的列，右边表对应的列会被赋空值，右连接同理。 一道简单的用左连接实现的题目示例： https://leetcode.cn/problems/combine-two-tables/description/ 全连接用union的实现 selectt1.c1,t2.c2fromt1leftjoint2ont1.c3=t2.c3unionselectt1.c1,t2.c2fromt1rightjoint2ont1.c3=t2.c3","date":"2022-08-14","objectID":"/posts/sql-1/:1:0","series":null,"tags":["数据库"],"title":"SQL-1","uri":"/posts/sql-1/#sql的连接"},{"categories":["数据库"],"content":"limit的使用查找第几大/第几小的元素下面为查找第二大薪资的示例，使用limit 1, 1即从第二个开始返回一个。需要注意的是使用distinct去重，不然可能出现多个最大值相同的情况，此时如果不去重返回的仍是最大值。 https://leetcode.cn/problems/second-highest-salary/description/ selectdistinctsalaryfromEmployeeorderbysalarydesclimit1,1另外一种解法，由于此题目的特殊性（求第二个），因此可以使用max函数来实现 selectmax(salary)fromEmployeewheresalary\u003c(selectmax(salary)fromEmployee)如果要求不存在返回null(只是本题需要),则使用ifNull selectifNull((selectmax(salary)fromEmployeewheresalary\u003c(selectmax(salary)fromEmployee)),null)asSecondHighestSalary","date":"2022-08-14","objectID":"/posts/sql-1/:2:0","series":null,"tags":["数据库"],"title":"SQL-1","uri":"/posts/sql-1/#limit的使用"},{"categories":["数据库"],"content":"limit的使用查找第几大/第几小的元素下面为查找第二大薪资的示例，使用limit 1, 1即从第二个开始返回一个。需要注意的是使用distinct去重，不然可能出现多个最大值相同的情况，此时如果不去重返回的仍是最大值。 https://leetcode.cn/problems/second-highest-salary/description/ selectdistinctsalaryfromEmployeeorderbysalarydesclimit1,1另外一种解法，由于此题目的特殊性（求第二个），因此可以使用max函数来实现 selectmax(salary)fromEmployeewheresalary","date":"2022-08-14","objectID":"/posts/sql-1/:2:0","series":null,"tags":["数据库"],"title":"SQL-1","uri":"/posts/sql-1/#查找第几大第几小的元素"},{"categories":["java基础"],"content":"Object类中有众多方法，其中包括equals() hashcode() ","date":"2020-07-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/object%E7%B1%BB%E6%96%B9%E6%B3%95/:0:0","series":null,"tags":null,"title":"Object类的方法","uri":"/posts/java%E5%9F%BA%E7%A1%80/object%E7%B1%BB%E6%96%B9%E6%B3%95/#"},{"categories":["java基础"],"content":"为什么重写equals也必须要重写hashcode我们知道，如果重写了equals,那么我们应该重写hashcode使得equals方法判定相同的两个对象的hashcode也必须相同，那么这是为什么呢?不重写会有什么问题？ 问题的关键在于HashMap等使用了对象的equals hashcode的方法。 在判断一个对象是否equals时，我们一般会先调用hashcode方法，因为相等的对象hashcode一定相同，而不相同的对象hashcode可能相同也可能不同，但是不同的hashcode的对象一定不同。 查看HashMap的源码，我们也可以看到这种逻辑, 可以看到hashmap在存放一个值时，会先看hashcode是否相同，如果不同会插入到链表尾部。假设我们定义了一个对象Person 包含id 姓名，我们重写了equals方法，认为id相同的person时equal的。但是如果我们没有重写hashcode方法，在插入时，就会存在两个相同id的person类而不是替换value，hashmap无法按我们的预想工作。 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) \u0026 hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node\u003cK,V\u003e e; K k; if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode\u003cK,V\u003e)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount \u003e= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size \u003e threshold) resize(); afterNodeInsertion(evict); return null; } final Node\u003cK,V\u003e getNode(Object key) { Node\u003cK,V\u003e[] tab; Node\u003cK,V\u003e first, e; int n, hash; K k; if ((tab = table) != null \u0026\u0026 (n = tab.length) \u003e 0 \u0026\u0026 (first = tab[(n - 1) \u0026 (hash = hash(key))]) != null) { if (first.hash == hash \u0026\u0026 // always check first node ((k = first.key) == key || (key != null \u0026\u0026 key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode\u003cK,V\u003e)first).getTreeNode(hash, key); do { if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 参考https://zhuanlan.zhihu.com/p/50206657 https://www.51cto.com/article/694975.html ","date":"2020-07-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/object%E7%B1%BB%E6%96%B9%E6%B3%95/:1:0","series":null,"tags":null,"title":"Object类的方法","uri":"/posts/java%E5%9F%BA%E7%A1%80/object%E7%B1%BB%E6%96%B9%E6%B3%95/#为什么重写equals也必须要重写hashcode"},{"categories":["java基础"],"content":"为什么重写equals也必须要重写hashcode我们知道，如果重写了equals,那么我们应该重写hashcode使得equals方法判定相同的两个对象的hashcode也必须相同，那么这是为什么呢?不重写会有什么问题？ 问题的关键在于HashMap等使用了对象的equals hashcode的方法。 在判断一个对象是否equals时，我们一般会先调用hashcode方法，因为相等的对象hashcode一定相同，而不相同的对象hashcode可能相同也可能不同，但是不同的hashcode的对象一定不同。 查看HashMap的源码，我们也可以看到这种逻辑, 可以看到hashmap在存放一个值时，会先看hashcode是否相同，如果不同会插入到链表尾部。假设我们定义了一个对象Person 包含id 姓名，我们重写了equals方法，认为id相同的person时equal的。但是如果我们没有重写hashcode方法，在插入时，就会存在两个相同id的person类而不是替换value，hashmap无法按我们的预想工作。 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) { Node[] tab; Node p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; if ((p = tab[i = (n - 1) \u0026 hash]) == null) tab[i] = newNode(hash, key, value, null); else { Node e; K k; if (p.hash == hash \u0026\u0026 ((k = p.key) == key || (key != null \u0026\u0026 key.equals(k)))) e = p; else if (p instanceof TreeNode) e = ((TreeNode)p).putTreeVal(this, tab, hash, key, value); else { for (int binCount = 0; ; ++binCount) { if ((e = p.next) == null) { p.next = newNode(hash, key, value, null); if (binCount = TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; } if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) break; p = e; } } if (e != null) { // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; } } ++modCount; if (++size threshold) resize(); afterNodeInsertion(evict); return null; } final Node getNode(Object key) { Node[] tab; Node first, e; int n, hash; K k; if ((tab = table) != null \u0026\u0026 (n = tab.length) 0 \u0026\u0026 (first = tab[(n - 1) \u0026 (hash = hash(key))]) != null) { if (first.hash == hash \u0026\u0026 // always check first node ((k = first.key) == key || (key != null \u0026\u0026 key.equals(k)))) return first; if ((e = first.next) != null) { if (first instanceof TreeNode) return ((TreeNode)first).getTreeNode(hash, key); do { if (e.hash == hash \u0026\u0026 ((k = e.key) == key || (key != null \u0026\u0026 key.equals(k)))) return e; } while ((e = e.next) != null); } } return null; } 参考https://zhuanlan.zhihu.com/p/50206657 https://www.51cto.com/article/694975.html ","date":"2020-07-01","objectID":"/posts/java%E5%9F%BA%E7%A1%80/object%E7%B1%BB%E6%96%B9%E6%B3%95/:1:0","series":null,"tags":null,"title":"Object类的方法","uri":"/posts/java%E5%9F%BA%E7%A1%80/object%E7%B1%BB%E6%96%B9%E6%B3%95/#参考"},{"categories":["java基础"],"content":"java中的访问控制符共有四种，它们分别是private, default, protected, public（按照从小到大排列） 总体的图： ","date":"2020-06-12","objectID":"/posts/java%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/:0:0","series":null,"tags":null,"title":"访问控制符","uri":"/posts/java%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/#"},{"categories":["java基础"],"content":"private只有当前类能访问，子类也不能访问 ","date":"2020-06-12","objectID":"/posts/java%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/:1:0","series":null,"tags":null,"title":"访问控制符","uri":"/posts/java%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/#private"},{"categories":["java基础"],"content":"default不加任何修饰符时的默认值，在同一包下就能访问。与是否子类无关 ","date":"2020-06-12","objectID":"/posts/java%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/:2:0","series":null,"tags":null,"title":"访问控制符","uri":"/posts/java%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/#default"},{"categories":["java基础"],"content":"protected范围包含了default, 但是区别在于不同包下子类的访问 不同包下子类可以通过自身引用访问，或者通过super关键字访问。也就是说只能通过继承得到的访问，而不能通过父类的实例访问。 假设有父类如下，它在com.protectedaccess.parentpackage包下 package com.protectedaccess.parentpackage; public class Parent { protected String protect = \"protect field\"; protected void getMessage(){ System.out.println(\"i am parent\"); } } 那么对于它的子类1 package com.protectedaccess.parentpackage.sonpackage1; import com.protectedaccess.parentpackage.Parent; public class Son1 extends Parent{ public static void main(String[] args) { Parent parent1 = new Parent(); // parent1.getMessage(); 错误 Parent parent2 = new Son1(); // parent2.getMessage(); 错误 Son1 son1 = new Son1(); son1.getMessage(); // 输出：i am parent, } private void message(){ getMessage(); // 如果子类重写了该方法， 则输出重写方法中的内容 super.getMessage(); // 输出父类该方法中的内容 } } ","date":"2020-06-12","objectID":"/posts/java%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/:3:0","series":null,"tags":null,"title":"访问控制符","uri":"/posts/java%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/#protected"},{"categories":["java基础"],"content":"public最宽泛的修饰符，大家都能访问 参考https://www.runoob.com/java/java-modifier-types.html#protected-desc https://juejin.cn/post/6844903517988061191 ","date":"2020-06-12","objectID":"/posts/java%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/:4:0","series":null,"tags":null,"title":"访问控制符","uri":"/posts/java%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/#public"},{"categories":["java基础"],"content":"public最宽泛的修饰符，大家都能访问 参考https://www.runoob.com/java/java-modifier-types.html#protected-desc https://juejin.cn/post/6844903517988061191 ","date":"2020-06-12","objectID":"/posts/java%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/:4:0","series":null,"tags":null,"title":"访问控制符","uri":"/posts/java%E5%9F%BA%E7%A1%80/%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/#参考"}]