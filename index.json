[{"categories":["test"],"content":"第一篇博客 注意\r\r啦啦啦啦啦\r\r ","date":"2023-05-30","objectID":"/posts/first_post/:0:0","series":null,"tags":["test"],"title":"First_post","uri":"/posts/first_post/#"},{"categories":["test"],"content":"标题哈哈哈哈哈111 1 2 3 4 2 3 2 2 2 2 2 附件二欧文覅 附件二欧韦杰夫 附件二欧锦 附件二哦i及 百度 ","date":"2023-05-30","objectID":"/posts/first_post/:1:0","series":null,"tags":["test"],"title":"First_post","uri":"/posts/first_post/#标题"},{"categories":["test"],"content":"testtest test test ","date":"2023-05-30","objectID":"/posts/first_post/:2:0","series":null,"tags":["test"],"title":"First_post","uri":"/posts/first_post/#test"},{"categories":["设计模式"],"content":"单例模式只允许创建一个对象，因此节省内存，加快对象访问速度，因此对象需要被公用的场合适合使用，如多个模块使用同一个数据源连接对象等等。如： 需要频繁实例化然后销毁的对象。 创建对象时耗时过多或者耗资源过多，但又经常用到的对象。 有状态的工具类对象。 频繁访问数据库或文件的对象。 以下都是单例模式的经典使用场景： 资源共享的情况下，避免由于资源操作时导致的性能或损耗等。如上述中的日志文件，应用配置。 控制资源的情况下，方便资源之间的互相通信。如线程池等。 ","date":"2022-09-14","objectID":"/posts/singleton_pattern/:0:0","series":null,"tags":["设计模式"],"title":"单例模式","uri":"/posts/singleton_pattern/#"},{"categories":["设计模式"],"content":"从饿汉式写法到懒汉式写法饿汉式就是用类变量存储初始化的实例。 public class Singleton { private static volatile Singleton singleton; private Singleton() { } public static Singleton getSingletonInstance(){ return singleton; } } 注意\r\r饿汉式的缺点是假设不需要用到这个类的实例，但是它仍然初始化了。实际应用中这并不是一个大问题。\r\r 懒汉式的写法最完美的是双重判断加锁，同时使用volatile保证可见性。 public class Singleton { private static volatile Singleton singleton; private Singleton() { } public static Singleton getSingletonInstance(){ if (singleton == null) { //可能两个线程同时判断通过 synchronized (Singleton.class) { try { Thread.sleep(1); } catch (InterruptedException e) { throw new RuntimeException(e); } if (singleton == null) { singleton = new Singleton(); } } } return singleton; } public static void main(String[] args) { for (int i = 0; i \u003c 1000; i ++) { new Thread(() -\u003e { System.out.println(Singleton.getInstance().hashCode()); }).start(); } } } ","date":"2022-09-14","objectID":"/posts/singleton_pattern/:1:0","series":null,"tags":["设计模式"],"title":"单例模式","uri":"/posts/singleton_pattern/#从饿汉式写法到懒汉式写法"},{"categories":["设计模式"],"content":"内部类在类中创建一个内部类，比懒汉式优雅，需要更高的jdk版本支持。 public class Singleton { private Singleton() { } private class SingletonInstance{ private final static Singleton INSTANCE= new Singleton(); } public static Singleton getInstance() { return SingletonInstance.INSTANCE; } public static void main(String[] args) { for (int i = 0; i \u003c 1000; i ++) { new Thread(() -\u003e { System.out.println(Singleton.getInstance().hashCode()); }).start(); } } } ","date":"2022-09-14","objectID":"/posts/singleton_pattern/:2:0","series":null,"tags":["设计模式"],"title":"单例模式","uri":"/posts/singleton_pattern/#内部类"},{"categories":["设计模式"],"content":"枚举最简单的当然还是枚举类了，在枚举类中，每个实例的类型就是该枚举类。如下面代码，INSTANCE的类型为SingletonEnum。 并且枚举类天生线程安全和单例。 public enum SingletonEnum{ INSTANCE; public static void main(String[] args) { for (int i = 0; i \u003c 1000; i ++) { new Thread(() -\u003e { System.out.println(SingletonEnum.INSTANCE.hashCode()); }).start(); } } } ","date":"2022-09-14","objectID":"/posts/singleton_pattern/:3:0","series":null,"tags":["设计模式"],"title":"单例模式","uri":"/posts/singleton_pattern/#枚举"}]